# Complete FREE Voice Bot Solution for Indian Users

## Option 1: Twilio Trial (Limited but Free)

### Setup Steps:

1. **Get Twilio Trial Account**
   - Sign up at Twilio.com
   - Get $15 credit + 1 free US number (works globally)
   - Note: You'll get a US number like `+1-XXX-XXX-XXXX`

2. **Verify Indian Phone Numbers**
   ```bash
   # In Twilio Console -> Phone Numbers -> Verified Caller IDs
   # Add each Indian number that should be able to call
   # Process: Enter number ‚Üí Receive SMS ‚Üí Enter verification code
   ```

3. **Who Can Call:**
   - ‚úÖ **You** (after verifying your Indian number)
   - ‚úÖ **Your test users** (after verifying their numbers)
   - ‚úÖ **Family/friends** (up to ~20 verified numbers)
   - ‚ùå **Random public users** (not verified)

4. **Call Flow:**
   - Indian user calls your US Twilio number: `+1-XXX-XXX-XXXX`
   - International calling rates apply to caller
   - Your bot responds in Hindi/English
   - Perfect for demos, testing, small user base

---

## Option 2: Alternative FREE Solutions (Public Access)

### A) Using WebRTC (Browser-based Calls)

Instead of phone calls, create a **web-based voice interface**:

```javascript
// Web app that users can access from browser
// Uses browser's built-in speech recognition + synthesis
// Completely free, no phone numbers needed

const recognition = new webkitSpeechRecognition();
recognition.lang = 'hi-IN'; // or 'en-US'
recognition.onresult = function(event) {
    const speechText = event.results[0][0].transcript;
    // Send to your HuggingFace API
    processUserSpeech(speechText);
};

const synthesis = window.speechSynthesis;
function speakResponse(text, lang) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang === 'hi' ? 'hi-IN' : 'en-US';
    synthesis.speak(utterance);
}
```

**Benefits:**
- ‚úÖ **Completely free**
- ‚úÖ **Anyone can access** via browser
- ‚úÖ **No phone number limitations**
- ‚úÖ **Works on mobile browsers**

### B) WhatsApp Business API (Voice Messages)

```javascript
// Users send voice messages to your WhatsApp Business number
// You process with speech-to-text and respond with voice
// Using Twilio WhatsApp API (also has free tier)

app.post('/whatsapp', async (req, res) => {
    const mediaUrl = req.body.MediaUrl0; // Voice message URL
    
    // Download and process voice message
    const audioBuffer = await downloadAudio(mediaUrl);
    const transcription = await speechToText(audioBuffer);
    
    // Get AI response
    const reply = await getHFReply(transcription);
    
    // Send voice reply back via WhatsApp
    await sendWhatsAppVoiceReply(reply, req.body.From);
});
```

---

## Option 3: Upgrade Strategy (Minimal Cost)

### For Real Business Use:

1. **Upgrade Twilio Account**: ~$20/month
   - ‚úÖ **Anyone can call** (no verification needed)
   - ‚úÖ **Get Indian local number** (+91-XXXX-XXXX)
   - ‚úÖ **Unlimited incoming calls**
   - ‚úÖ **Professional setup**

2. **Alternative: Indian VoIP Providers**
   - **Exotel**: Indian company, competitive rates
   - **Knowlarity**: Supports Hindi STT/TTS
   - **Ozonetel**: Good for Indian market

---

## Recommended FREE Approach for Testing:

### 1. Start with WebRTC Version

Create a simple web app that users can visit:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Photography Studio Voice Assistant</title>
</head>
<body>
    <h1>üé§ Voice Assistant</h1>
    <button id="startBtn">Start Speaking (Hindi/English)</button>
    <div id="transcript"></div>
    <div id="response"></div>
    
    <script>
        // Your voice recognition + HuggingFace integration
        // Users simply visit your website and click to talk
    </script>
</body>
</html>
```

### 2. For Demo Purposes: Use Twilio Trial

- Verify 5-10 key phone numbers (friends, family, potential clients)
- Use US Twilio number for demos
- Explain to users: "Call this US number to test our voice assistant"

### 3. Scale Up When Ready

- Once you have paying customers, upgrade Twilio
- Get Indian local number
- Enable public access

---

## Complete Code for WebRTC Version

Want me to create the **browser-based voice assistant** that works immediately without any phone number limitations? It would be:

- ‚úÖ **100% Free**
- ‚úÖ **Public access** (anyone can use)
- ‚úÖ **Hindi + English support**
- ‚úÖ **Works on mobile**
- ‚úÖ **No verification needed**

This might actually be **better** than phone calls for most users, especially younger demographics who prefer web/app interfaces.

---

## Summary

**For Testing/Demo:** Use Twilio trial + verify key numbers
**For Public Launch:** Use WebRTC browser version (free) or upgrade Twilio (~$20/month)
**For Business:** Upgrade to paid Twilio or use Indian VoIP providers

Which approach would you like me to implement first?


//code snippet

// index.js - Enhanced with Hindi + English support
import express from "express";
import bodyParser from "body-parser";
import { urlencoded } from "body-parser";
import fetch from "node-fetch";
import { twiml } from "twilio";
import dotenv from "dotenv";

dotenv.config();
const app = express();
app.use(bodyParser.json());
app.use(urlencoded({ extended: false }));

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN,
  TWILIO_NUMBER,
  HF_TOKEN,
  HF_MODEL,
} = process.env;

// Language detection helper
function detectLanguage(text) {
  // Simple language detection based on script
  const hindiPattern = /[\u0900-\u097F]/; // Devanagari script
  return hindiPattern.test(text) ? 'hi' : 'en';
}

// ‚îÄ‚îÄ‚îÄ 1) Incoming Call Handler with Language Selection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.post("/voice", (req, res) => {
  const twimlResponse = new twiml.VoiceResponse();

  // Check if user has already selected a language
  const selectedLang = req.body.Digits || req.query.lang;
  
  if (!selectedLang) {
    // Language selection menu
    const gather = twimlResponse.gather({
      action: "/language-select",
      method: "POST",
      input: "dtmf",
      numDigits: 1,
      timeout: 10,
    });

    gather.say(
      { voice: "alice", language: "en-US" },
      "Welcome! Press 1 for English or 2 for Hindi. ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è 1 ‡§Ø‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è 2 ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§"
    );

    twimlResponse.redirect("/voice");
  } else {
    // Start conversation in selected language
    startConversation(twimlResponse, selectedLang);
  }

  res.type("text/xml");
  res.send(twimlResponse.toString());
});

// ‚îÄ‚îÄ‚îÄ 2) Language Selection Handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.post("/language-select", (req, res) => {
  const selectedDigit = req.body.Digits;
  const twimlResponse = new twiml.VoiceResponse();

  if (selectedDigit === "1") {
    startConversation(twimlResponse, "en");
  } else if (selectedDigit === "2") {
    startConversation(twimlResponse, "hi");
  } else {
    // Invalid selection, try again
    twimlResponse.say(
      { voice: "alice", language: "en-US" },
      "Invalid selection. Please try again."
    );
    twimlResponse.redirect("/voice");
  }

  res.type("text/xml");
  res.send(twimlResponse.toString());
});

// ‚îÄ‚îÄ‚îÄ 3) Start Conversation in Selected Language ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startConversation(twimlResponse, language) {
  const gather = twimlResponse.gather({
    action: `/gather?lang=${language}`,
    method: "POST",
    input: "speech",
    speechModel: "default",
    language: language === "hi" ? "hi-IN" : "en-US",
    hints: language === "hi" ? 
      "‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó, ‡§ë‡§∞‡•ç‡§°‡§∞, ‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ö‡§™‡•â‡§á‡§Ç‡§ü‡§Æ‡•á‡§Ç‡§ü, ‡§∏‡•ç‡§•‡§ø‡§§‡§ø" : 
      "booking, order, appointment, status, help",
    timeout: 5,
  });

  if (language === "hi") {
    gather.say(
      { voice: "Polly.Priya", language: "hi-IN" },
      "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§´‡§º‡•ã‡§ü‡•ã‡§ó‡•ç‡§∞‡§æ‡§´‡•Ä ‡§∏‡•ç‡§ü‡•Ç‡§°‡§ø‡§Ø‡•ã ‡§∏‡§π‡§æ‡§Ø‡§ø‡§ï‡§æ ‡§π‡•Ç‡§Å‡•§ ‡§Ü‡§™ ‡§ï‡•ç‡§Ø‡§æ ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç? ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§®‡§Ø‡§æ ‡§Ö‡§™‡•â‡§á‡§Ç‡§ü‡§Æ‡•á‡§Ç‡§ü ‡§¨‡•Å‡§ï ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§Ö‡§™‡§®‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§™‡•Ç‡§õ‡•á‡§Ç‡•§"
    );
  } else {
    gather.say(
      { voice: "alice", language: "en-US" },
      "Hello! I'm your photography studio assistant. How can I help you today? You can book a new appointment, check your order status, or ask any questions."
    );
  }

  twimlResponse.redirect(`/voice?lang=${language}`);
}

// ‚îÄ‚îÄ‚îÄ 4) Handle Transcribed Speech (Bilingual) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.post("/gather", async (req, res) => {
  const speechText = req.body.SpeechResult || "";
  const selectedLang = req.query.lang || detectLanguage(speechText);
  
  console.log(`Transcribed (${selectedLang}):`, speechText);

  // Process the request
  let assistantReply = await processRequest(speechText, selectedLang);

  const twimlResponse = new twiml.VoiceResponse();
  
  if (selectedLang === "hi") {
    twimlResponse.say(
      { voice: "Polly.Priya", language: "hi-IN" },
      assistantReply
    );
  } else {
    twimlResponse.say(
      { voice: "alice", language: "en-US" },
      assistantReply
    );
  }

  // Option to continue conversation or hang up
  const gather = twimlResponse.gather({
    action: `/gather?lang=${selectedLang}`,
    method: "POST",
    input: "speech",
    speechModel: "default",
    language: selectedLang === "hi" ? "hi-IN" : "en-US",
    timeout: 3,
  });

  if (selectedLang === "hi") {
    gather.say(
      { voice: "Polly.Priya", language: "hi-IN" },
      "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™‡§ï‡§æ ‡§ï‡•ã‡§à ‡§î‡§∞ ‡§∏‡§µ‡§æ‡§≤ ‡§π‡•à?"
    );
  } else {
    gather.say(
      { voice: "alice", language: "en-US" },
      "Do you have any other questions?"
    );
  }

  twimlResponse.hangup();

  res.type("text/xml");
  res.send(twimlResponse.toString());
});

// ‚îÄ‚îÄ‚îÄ 5) Process Requests with Built-in Logic + LLM Fallback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function processRequest(userText, language) {
  const textLower = userText.toLowerCase();
  
  // Appointment booking logic
  if (isBookingRequest(textLower, language)) {
    return handleBooking(userText, language);
  }
  
  // Order tracking logic
  if (isOrderTrackingRequest(textLower, language)) {
    return handleOrderTracking(userText, language);
  }
  
  // Pricing inquiry
  if (isPricingRequest(textLower, language)) {
    return handlePricing(language);
  }
  
  // Fallback to LLM for general questions
  return await getHFReply(userText, language);
}

// ‚îÄ‚îÄ‚îÄ 6) Built-in Business Logic Functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function isBookingRequest(text, lang) {
  const hindiKeywords = ["‡§Ö‡§™‡•â‡§á‡§Ç‡§ü‡§Æ‡•á‡§Ç‡§ü", "‡§¨‡•Å‡§ï", "‡§¨‡•Å‡§ï‡§ø‡§Ç‡§ó", "‡§Æ‡§ø‡§≤‡§®‡§æ", "‡§∏‡§Æ‡§Ø"];
  const englishKeywords = ["appointment", "book", "booking", "schedule", "meet"];
  const keywords = lang === "hi" ? hindiKeywords : englishKeywords;
  return keywords.some(keyword => text.includes(keyword));
}

function isOrderTrackingRequest(text, lang) {
  const hindiKeywords = ["‡§ë‡§∞‡•ç‡§°‡§∞", "‡§∏‡•ç‡§•‡§ø‡§§‡§ø", "‡§ü‡•ç‡§∞‡•à‡§ï", "‡§ï‡§π‡§æ‡§Ç", "‡§ï‡§¨"];
  const englishKeywords = ["order", "status", "track", "where", "when"];
  const keywords = lang === "hi" ? hindiKeywords : englishKeywords;
  return keywords.some(keyword => text.includes(keyword));
}

function isPricingRequest(text, lang) {
  const hindiKeywords = ["‡§ï‡•Ä‡§Æ‡§§", "‡§∞‡•á‡§ü", "‡§™‡•à‡§∏‡•á", "‡§∞‡•Å‡§™‡§Ø‡•á", "‡§´‡•Ä‡§∏"];
  const englishKeywords = ["price", "cost", "rate", "money", "fee", "charge"];
  const keywords = lang === "hi" ? hindiKeywords : englishKeywords;
  return keywords.some(keyword => text.includes(keyword));
}

function handleBooking(userText, language) {
  // In a real app, you'd parse date/time and save to database
  if (language === "hi") {
    return "‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§™‡•â‡§á‡§Ç‡§ü‡§Æ‡•á‡§Ç‡§ü ‡§¨‡•Å‡§ï ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§ü‡•Ä‡§Æ 24 ‡§ò‡§Ç‡§ü‡•á ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§ó‡•Ä‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™‡§ï‡•ã ‡§ï‡•ã‡§à ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§∏‡§Æ‡§Ø ‡§™‡§∏‡§Ç‡§¶ ‡§π‡•à?";
  } else {
    return "Thank you for booking an appointment! Our team will contact you within 24 hours. Do you have any preferred time slots?";
  }
}

function handleOrderTracking(userText, language) {
  // In a real app, you'd query your order database
  if (language === "hi") {
    return "‡§Ü‡§™‡§ï‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§Ç ‡§π‡•à ‡§î‡§∞ 3-5 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•ã ‡§ú‡§æ‡§è‡§ó‡§æ‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è SMS ‡§Æ‡§ø‡§≤‡•á‡§ó‡§æ‡•§";
  } else {
    return "Your order is currently being processed and will be ready in 3-5 days. You'll receive SMS updates on the progress.";
  }
}

function handlePricing(language) {
  if (language === "hi") {
    return "‡§π‡§Æ‡§æ‡§∞‡•á ‡§´‡•ã‡§ü‡•ã‡§∂‡•Ç‡§ü ‡§™‡•à‡§ï‡•á‡§ú 5000 ‡§∞‡•Å‡§™‡§Ø‡•á ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§™‡•ã‡§∞‡•ç‡§ü‡•ç‡§∞‡•á‡§ü ‡§∏‡•á‡§∂‡§® 3000 ‡§∞‡•Å‡§™‡§Ø‡•á, ‡§µ‡•á‡§°‡§ø‡§Ç‡§ó ‡§™‡•à‡§ï‡•á‡§ú 25000 ‡§∞‡•Å‡§™‡§Ø‡•á ‡§∏‡•á‡•§ ‡§Ö‡§ß‡§ø‡§ï ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§µ‡•á‡§¨‡§∏‡§æ‡§á‡§ü ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§";
  } else {
    return "Our photoshoot packages start from 5000 rupees. Portrait sessions are 3000 rupees, wedding packages start from 25000 rupees. Visit our website for detailed pricing.";
  }
}

// ‚îÄ‚îÄ‚îÄ 7) Enhanced HF API Call with Language Support ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function getHFReply(userText, language) {
  try {
    const systemPrompt = language === "hi" ? 
      "‡§Ü‡§™ ‡§è‡§ï ‡§´‡•ã‡§ü‡•ã‡§ó‡•ç‡§∞‡§æ‡§´‡•Ä ‡§∏‡•ç‡§ü‡•Ç‡§°‡§ø‡§Ø‡•ã ‡§ï‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§ø‡§ï‡§æ ‡§π‡•à‡§Ç‡•§ ‡§ó‡•ç‡§∞‡§æ‡§π‡§ï‡•ã‡§Ç ‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡•á‡§Ç‡•§" :
      "You are a photography studio assistant. Help customers with their queries.";
    
    const prompt = language === "hi" ?
      `System: ${systemPrompt}\nUser: ${userText}\nAssistant (in Hindi):` :
      `System: ${systemPrompt}\nUser: ${userText}\nAssistant:`;

    const payload = {
      inputs: prompt,
      options: { 
        wait_for_model: true, 
        use_cache: false,
        max_length: 150,
        temperature: 0.7
      },
    };

    const response = await fetch(
      `https://api-inference.huggingface.co/models/${HF_MODEL}`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${HF_TOKEN}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      }
    );

    if (!response.ok) {
      console.error("HF inference error:", await response.text());
      return language === "hi" ?
        "‡§ï‡•ç‡§∑‡§Æ‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§á‡§∏ ‡§∏‡§Æ‡§Ø ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§™‡§æ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§" :
        "Sorry, I'm unable to assist you right now. Please try again later.";
    }

    const data = await response.json();
    let generated = "";
    
    if (Array.isArray(data) && data[0].generated_text) {
      generated = data[0].generated_text;
    } else if (data.generated_text) {
      generated = data.generated_text;
    } else {
      return language === "hi" ?
        "‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§∏‡§Æ‡§ù ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§ï‡§π‡•á‡§Ç‡•§" :
        "I didn't understand your message. Please try again.";
    }

    // Clean up the response
    const assistantMarker = language === "hi" ? "Assistant (in Hindi):" : "Assistant:";
    if (generated.includes(assistantMarker)) {
      generated = generated.split(assistantMarker).pop().trim();
    }
    
    // Remove any remaining system prompts
    if (generated.includes("System:") || generated.includes("User:")) {
      const lines = generated.split('\n');
      generated = lines[lines.length - 1].trim();
    }
    
    return generated || (language === "hi" ? 
      "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å‡•§" : 
      "I'm trying to help you with that.");

  } catch (err) {
    console.error("Error in getHFReply:", err);
    return language === "hi" ?
      "‡§ï‡•ç‡§∑‡§Æ‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§ï‡•Å‡§õ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•ã ‡§ó‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§" :
      "Sorry, there was an error. Please try again later.";
  }
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`‚û§ Bilingual Voice Bot Server listening on http://localhost:${PORT}`);
  console.log(`‚û§ Supports: Hindi (hi-IN) and English (en-US)`);
});